var documenterSearchIndex = {"docs":
[{"location":"#Features-implemented","page":"Features implemented","title":"Features implemented","text":"","category":"section"},{"location":"#Circular-waves","page":"Features implemented","title":"Circular waves","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"b̃p\nβp\nbp\nsolution_surrogate","category":"page"},{"location":"#StableApproxEPW.b̃p","page":"Features implemented","title":"StableApproxEPW.b̃p","text":"b̃p(p; k=1)\n\nClosure for the circular wave function in polar coordinates.\n\nThe closure captures the values of the mode number p as well as the wavenumber k and does not include any normalization. The function can then be evaluated at any (rθ) point.\n\nThe circular waves in polar coordinates are defined by\n\nb_p = (rθ)  J_p(kr) e^ı p θ qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.βp","page":"Features implemented","title":"StableApproxEPW.βp","text":"βp(p; k=1)\n\nComputation of the normalization constant of the circular waves.\n\nThe circular wave is defined by b̃p and the normalization is done using the k-weighted H^1 norm.\n\nBy definition\n\n     b_p _H^1^2 =  b_p _L^2^2 + k^-2  nabla b_p _L^2^2\n\nUsing integration by parts,\n\n     nabla b_p _L^2^2 = k^2  b_p _L^2^2 + (partial_n b_p  b_p)\n\nOn the one hand\n\n     b_p _L^2^2 = pi (J_p^2(k) - J_p-1(k)J_p+1(k))\n\nOn the other hand\n\n    (partial_n b_p  b_p) = pi k (J_p-1(k) - J_p+1(k))J_p(k)\n\nHence\n\n     b_p _H^1^2 = 2pi (J_p^2(k) - J_p-1(k)J_p+1(k))\n    + pi k^-1 (J_p-1(k) - J_p+1(k))J_p(k)\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.bp","page":"Features implemented","title":"StableApproxEPW.bp","text":"bp(p; k=1)\n\nClosure for the normalized circular waves.\n\nThe closure captures the values of the mode number p and the wavenumber k. The normalization is the default normalization defined in the function βp and is precomputed once for all. The function can then be evaluated at any (rθ) point.\n\nThe normalized circular waves are defined by\n\nb_p = β_p b_p qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.solution_surrogate","page":"Features implemented","title":"StableApproxEPW.solution_surrogate","text":"solution_surrogate(U; k=1)\n\nComputes a solution surrogate from a set of coefficients U.\n\nThe parameter U is a vector of coefficients u_p for p ranging from -P to P (hence of size 2P+1). The solution surrogate is then\n\nmathbfx  sum_p leq P u_p b_p(mathbfx)\n\n\n\n\n\n","category":"function"},{"location":"#Herglotz-densities","page":"Features implemented","title":"Herglotz densities","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"ãp\nwz\nαp\nap","category":"page"},{"location":"#StableApproxEPW.ãp","page":"Features implemented","title":"StableApproxEPW.ãp","text":"ãp(p)\n\nClosure for the Herglotz polynomial.\n\nThe closure captures the values of the mode number p and does not include any normalization. The function can then be evaluated at any (ζφ) point in the complex strip. Here ζ is the evanescence parameter and φ is the angle indicating the direction of propagation.\n\nThe Herglotz polynomials are defined by\n\na_p = (ζφ)  e^p (ζ + ıφ) qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.wz","page":"Features implemented","title":"StableApproxEPW.wz","text":"wz(; k=1, z=1/4)\n\nClosure to define the weight function.\n\nThe closure captures the values of the wavenumber k and a parameter z. The function can then be evaluated at any ζ point.\n\nThe weight function is defined as\n\nw = ζ  e^z ζ - k sinhζ qquad  ζ  mathbbR\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.αp","page":"Features implemented","title":"StableApproxEPW.αp","text":"αp(p, logweight)\n\nComputation of the normalization constant of the Herglotz polynomial.\n\nThe Herglotz polynomial is defined by a_p, see the function ãp. The normalization constant is defined by\n\nα_p^-2 = 2π int_mathbbR a_p^2 w^2 mathrmdzeta\n\nwhere w is the weight function. The weight function w can be taken to be the function wz.\n\nThe implementation relies on the convenience functions ϵsupport and adaptive_G_quad.\n\ndanger: Beware!\nThe second argument expects the log of the weight function w. This is for numerical stability reasons.\n\nwarning: Warning!\nThe implementation uses some ad-hoc adaptive Gauss quadrature routine. There is probably some room for improvement in the implementation.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.ap","page":"Features implemented","title":"StableApproxEPW.ap","text":"ap(p, logweight)\n\nClosure for the normalized Herglotz polynomial.\n\nThe closure captures the values of the mode number p. The Herglotz polynomial is defined by a_p, see the function ãp. The normalization is given by the second argument, as defined in the documentation of the function αp and is precomputed once for all. The function can then be evaluated at any (ζφ) point in the complex strip. Here ζ is the evanescence parameter and φ is the angle indicating the direction of propagation.\n\nThe normalized Herglotz polynomials are defined by\n\na_p = α_p a_p qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"#Generalized-plane-waves","page":"Features implemented","title":"Generalized plane waves","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"gpw\napproximation_set","category":"page"},{"location":"#StableApproxEPW.gpw","page":"Features implemented","title":"StableApproxEPW.gpw","text":"gpw(ζ, φ; k=1)\n\nClosure that defines a generalized plane wave in polar coordinates.\n\nThe closure captures the values of the evanescence parameter ζ, the angle φ and the wavenumber k. It does not include any normalization. The function can then be evaluated at any (rθ) point.\n\nThe generalized plane wave in polar coordinates is defined by\n\nϕ = (rθ)  e^ı k mathbfd  mathbfx\n\nwhere\n\nmathbfd = (cosφ+ıζ sinφ+ıζ)\nqquadtextandqquad\nmathbfx = (r cos θ rsin θ)\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.approximation_set","page":"Features implemented","title":"StableApproxEPW.approximation_set","text":"approximation_set(Y, W; k=1)\n\nGenerate a set of generalized plane waves.\n\nThe parameters Y and W are respectively the sets of complex angles (ζ_jφ_j) and associated weights ω_j corresponding to the generalized plane waves, see gpw\n\nϕ_j = (rθ)  e^ı k mathbfd_j  mathbfx\n\nwhere\n\nmathbfd_j = (cosφ_j+ıζ_j sinφ_j+ıζ_j)\nqquadtextandqquad\nmathbfx = (r cos θ rsin θ)\n\nApproximations are constructed in the form of\n\n(r θ)  sum_j ξ_j ω_j ϕ_j(r θ)\n\nwhere (ξ_j)_j is the set of unknown coefficients.\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\napproximation_set(N; k=1)\n\nGenerate a set of N propagative plane waves with equispaced angles.\n\nThe equispaced angles are defined by\n\nθ_n = 2π s  R qquad n = 0N-1\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\napproximation_set(N, qs, smpl_type; k=1)\napproximation_set(N, Q::Integer, smpl_type; k=1)\n\nGenerate a set of N evanescent plane waves according to some sampling type.\n\nThe second parameter can be an integer Q which controls the truncation parameter of the TruncKernel, or a set of integers qs to specify only some specific terms in the expansion. The parameter smpl_type should be a function name: see uniform_sampling, sobol_sampling and random_sampling.\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\n","category":"function"},{"location":"#Regularized-SVD-approximation","page":"Features implemented","title":"Regularized SVD approximation","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"RegularizedSVDPseudoInverse\ncondition_number\nsolve_via_regularizedSVD","category":"page"},{"location":"#StableApproxEPW.RegularizedSVDPseudoInverse","page":"Features implemented","title":"StableApproxEPW.RegularizedSVDPseudoInverse","text":"RegularizedSVDPseudoInverse(A; ϵ=1e-8)\n\nStructure able to solve linear system A using a regularized SVD.\n\nThe threshold ϵ controls the regularization.  Let σ_max be the larger singular value. A singular value σ such that σ leq ϵ σ_max is approximated by zero when solving the least-squares problem.\n\n\n\n\n\n","category":"type"},{"location":"#StableApproxEPW.condition_number","page":"Features implemented","title":"StableApproxEPW.condition_number","text":"condition_number(B::RegularizedSVDPseudoInverse)\n\nComputes condition number of the matrix for which B was constructed.\n\nThe condition number is defined as the ratio of the largest over the smallest singular values of the matrix A.\n\nκ = fracσ_maxσ_min\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.solve_via_regularizedSVD","page":"Features implemented","title":"StableApproxEPW.solve_via_regularizedSVD","text":"solve_via_regularizedSVD(B::RegularizedSVDPseudoInverse, b)\n\nSolve the linear system Ax=b using the regularized SVD of A.\n\n\n\n\n\n","category":"function"},{"location":"#Parametric-sampling","page":"Features implemented","title":"Parametric sampling","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"TruncKernel\nkernel_diagonal\nprobabilitydensityfunction\ncumulativedensityfunction\nSampler\ninversion\nweight\nrandom_sampling\nuniform_sampling\nsobol_sampling","category":"page"},{"location":"#StableApproxEPW.TruncKernel","page":"Features implemented","title":"StableApproxEPW.TruncKernel","text":"TruncKernel(P::Integer, logweight)\nTruncKernel(ps::NTuple{N,Int64}, logweight) where N\n\nStructure to hold precomputed normalization constants of Herglotz polynomials.\n\nThis is a convenience structure to hold precomputed normalization constants αp of Herglotz polynomials which are expensive to compute.\n\nAll the normalized Herglotz polynomials a_p (see ap) for p in the argument ps (noted mathcalP) are precomputed and stored in the attribute as which is a Tuple. The logweight function is used to compute the normalization constants. If only an Integer P is given as first argument, the terms in the kernel are the a_p functions for p ranging from -P to P.\n\nA kernel can be evaluated at (x,y) where x=(ζx,φx) and y=(ζy,φy) are points in the complex strip.\n\n(mathbfxmathbfy)  K(mathbfx mathbfy)\n= sum_p in mathcalP overlinea_p(mathbfx) a_p(mathbfy)\n\n\n\n\n\n","category":"type"},{"location":"#StableApproxEPW.kernel_diagonal","page":"Features implemented","title":"StableApproxEPW.kernel_diagonal","text":"kernel_diagonal(K::TruncKernel)\n\nClosure that defines the evaluation function of the diagonal of a TruncKernel.\n\nmathbfy  K(mathbfy mathbfy)\n= sum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.probabilitydensityfunction","page":"Features implemented","title":"StableApproxEPW.probabilitydensityfunction","text":"probabilitydensityfunction(K::TruncKernel)\n\nProbability density function defined by a TruncKernel.\n\n(ζ φ)  frac1mathcalP K(mathbfy mathbfy)\n= frac1mathcalP sum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\nNotice that it is indeed a PDF since all the a_p functions are orthonormal.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.cumulativedensityfunction","page":"Features implemented","title":"StableApproxEPW.cumulativedensityfunction","text":"cumulativedensityfunction(K::TruncKernel)\n\nCumulative density function defined by a TruncKernel.\n\nThe probability density function is provided by the function probabilitydensityfunction.\n\nζ  frac2πmathcalP int_-infty^ζ K(ζζ) mathrmdζ\n= frac2πmathcalP int_-infty^ζ sum_p in mathcalP a_p^2(ζ) mathrmdζ\n\nwhere, abusing notations, we used K(ζζ) = K(mathbfymathbfy) and a_p^2(ζ) = a_p^2(mathbfy) for any mathbfy = (ζφ) since they both are quantities independent of φ.\n\nThe implementation relies on the convenience functions ϵsupport and adaptive_G_quad.\n\ndanger: Beware!\nThe implementation assumes that the probability density function is constant with respect to the second variable φ. This is the reason why the resulting CDF is a univariate function.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.Sampler","page":"Features implemented","title":"StableApproxEPW.Sampler","text":"Sampler(K::TruncKernel)\n\nStructure to compute sampling nodes and weights.\n\nThe nodes and weights are sampled according to the probability density function defined by a TruncKernel.\n\nnote: Note!\nThe implementation uses the secant method as root finding algorithm to compute the pre-image of the CDF. There is probably some room for improvement in the implementation, specially since we know that the first derivative of the CDF is the PDF. The Newton-Raphson method fails to converge for instance.\n\n\n\n\n\n","category":"type"},{"location":"#StableApproxEPW.inversion","page":"Features implemented","title":"StableApproxEPW.inversion","text":"inversion(smpl::Sampler, u)\n\nComputes the pre-image ζ of u under the cumulative density function.\n\nThis function allows to perform Inversion Transform Sampling.\n\nThis is a univariate inversion function because the cdf is constant with respect to the other variable φ.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.weight","page":"Features implemented","title":"StableApproxEPW.weight","text":"weight(smpl::Sampler, node)\n\nComputes the weight associated to a node (ζφ).\n\nThe weight at mathbfy=(ζφ) is defined by\n\nω(mathbfy) = sqrtfracmathcalPsum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.random_sampling","page":"Features implemented","title":"StableApproxEPW.random_sampling","text":"random_sampling(smpl::Sampler)\nrandom_sampling(smpl::Sampler, M)\n\nDraw M random samples according to the distribution stored in smpl.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.uniform_sampling","page":"Features implemented","title":"StableApproxEPW.uniform_sampling","text":"uniform_sampling(smpl::Sampler, M)\n\nDraw M deterministic samples according to the distribution stored in smpl.\n\nThis has a tensor-like structure, with the same number of samples in both directions.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.sobol_sampling","page":"Features implemented","title":"StableApproxEPW.sobol_sampling","text":"sobol_sampling(smpl::Sampler, M)\n\nDraw M quasi-random samples according to the distribution stored in smpl.\n\nThis function uses Sobol sequences computed according to the package QuasiMonteCarlo.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Dirichlet-sampling","page":"Features implemented","title":"Dirichlet sampling","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"samples_from_nodes\nboundary_sampling_nodes\nnumber_of_boundary_sampling_nodes\nDirichlet_sampling","category":"page"},{"location":"#StableApproxEPW.samples_from_nodes","page":"Features implemented","title":"StableApproxEPW.samples_from_nodes","text":"samples_from_nodes(f, X)\nsamples_from_nodes(f::Vector, X)\n\nEvaluate f at the sampling nodes X.\n\nIf f is a vector, a matrix is computed.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.boundary_sampling_nodes","page":"Features implemented","title":"StableApproxEPW.boundary_sampling_nodes","text":"boundary_sampling_nodes(S)\n\nThe sampling nodes on the boundary of the unit disk.\n\nThe samplings nodes are then (1 θ_s) with\n\nθ_s = 2π s  S qquad s = 0S-1\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.number_of_boundary_sampling_nodes","page":"Features implemented","title":"StableApproxEPW.number_of_boundary_sampling_nodes","text":"number_of_boundary_sampling_nodes(M; η=2, P=0)\n\nNumber of sampling nodes necessary for an approximation set of dimension M.\n\nThe number of sampling points on the boundary of the unit disk is given by S = max(ηM 2P+1). The (overdetermined) linear system that will be solved is then of size S by M.\n\nThe oversampling parameter η defaults to 2 but can be provided by the user as an optional parameter η. The mode number P defaults to 0 but can be provided by the user as an optional parameter P.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.Dirichlet_sampling","page":"Features implemented","title":"StableApproxEPW.Dirichlet_sampling","text":"Dirichlet_sampling(k, N, U; smpl_type=nothing, η=2, ϵ=1e-8, Q=(length(U)-1)//2)\n\nExample of reconstruction of a solution surrogate via Dirichlet sampling.\n\nThe solution surrogate is defined by its vector of coefficients U. The approximation set of dimension N can be composed of propagative plane waves (default) or evanescent plane waves (depending on the value of smpl_type and Q the maximum mode number assumed to be in the target). The number of sampling points on the boundary can be controlled via the oversampling ration η. The amount of regularization in the SVD can be controlled by the regularization parameter ϵ.\n\n\n\n\n\n","category":"function"},{"location":"#Convenience-functions","page":"Features implemented","title":"Convenience functions","text":"","category":"section"},{"location":"","page":"Features implemented","title":"Features implemented","text":"ϵsupport\nadaptive_G_quad","category":"page"},{"location":"#StableApproxEPW.ϵsupport","page":"Features implemented","title":"StableApproxEPW.ϵsupport","text":"function ϵsupport(f, ϵ; δ=1e-3)\n\nComputes the ϵ-support of a function.\n\nThis is useful to compute quadratures of compactly ϵ-supported functions on unbounded domains.\n\n\n\n\n\n","category":"function"},{"location":"#StableApproxEPW.adaptive_G_quad","page":"Features implemented","title":"StableApproxEPW.adaptive_G_quad","text":"adaptive_G_quad(f; quadrule=gausslegendre, a=-1, b=1)\n\nComputes the integral of f on ab using adaptive quadrature rule.\n\nHere adaptivity is only understood with respect to the number of nodes. There is no-subdivision of the interval.\n\nnote: Note!\nThe default implementation relies on the FastGaussQuadrature.jl package through the gausslegendre quadrature rule function.\n\n\n\n\n\n","category":"function"}]
}
