var documenterSearchIndex = {"docs":
[{"location":"#Stable-Approximation-of-Helmholtz-Solutions-by-Evanescent-Plane-Waves","page":"Getting started","title":"Stable Approximation of Helmholtz Solutions by Evanescent Plane Waves","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Companion repository of the eponym paper","category":"page"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"Install from the Pkg REPL:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"pkg> add https://github.com/EmileParolin/evanescent-plane-wave-approx","category":"page"},{"location":"#Reference","page":"Getting started","title":"Reference","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"E. Parolin, D. Huybrechs and A. Moiola, Stable Approximation of Helmholtz Solutions by Evanescent Plane Waves, In preparation.","category":"page"},{"location":"implementation/#Features-implemented","page":"Source","title":"Features implemented","text":"","category":"section"},{"location":"implementation/#Circular-waves","page":"Source","title":"Circular waves","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"b̃p\nβp\nbp\nsolution_surrogate","category":"page"},{"location":"implementation/#StableApproxEPW.b̃p","page":"Source","title":"StableApproxEPW.b̃p","text":"b̃p(p; k=1)\n\nClosure for the circular wave function in polar coordinates.\n\nThe closure captures the values of the mode number p as well as the wavenumber k and does not include any normalization. The function can then be evaluated at any (rθ) point.\n\nThe circular waves in polar coordinates are defined by\n\nb_p = (rθ)  J_p(kr) e^ı p θ qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.βp","page":"Source","title":"StableApproxEPW.βp","text":"βp(p; k=1)\n\nComputation of the normalization constant of the circular waves.\n\nThe circular wave is defined by b̃p and the normalization is done using the k-weighted H^1 norm.\n\nBy definition\n\n     b_p _H^1^2 =  b_p _L^2^2 + k^-2  nabla b_p _L^2^2\n\nUsing integration by parts,\n\n     nabla b_p _L^2^2 = k^2  b_p _L^2^2 + (partial_n b_p  b_p)\n\nOn the one hand\n\n     b_p _L^2^2 = pi (J_p^2(k) - J_p-1(k)J_p+1(k))\n\nOn the other hand\n\n    (partial_n b_p  b_p) = pi k (J_p-1(k) - J_p+1(k))J_p(k)\n\nHence\n\n     b_p _H^1^2 = 2pi (J_p^2(k) - J_p-1(k)J_p+1(k))\n    + pi k^-1 (J_p-1(k) - J_p+1(k))J_p(k)\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.bp","page":"Source","title":"StableApproxEPW.bp","text":"bp(p; k=1)\n\nClosure for the normalized circular waves.\n\nThe closure captures the values of the mode number p and the wavenumber k. The normalization is the default normalization defined in the function βp and is precomputed once for all. The function can then be evaluated at any (rθ) point.\n\nThe normalized circular waves are defined by\n\nb_p = β_p b_p qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.solution_surrogate","page":"Source","title":"StableApproxEPW.solution_surrogate","text":"solution_surrogate(U; k=1)\n\nComputes a solution surrogate from a set of coefficients U.\n\nThe parameter U is a vector of coefficients u_p for p ranging from -P to P (hence of size 2P+1). The solution surrogate is then\n\nmathbfx  sum_p leq P u_p b_p(mathbfx)\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Herglotz-densities","page":"Source","title":"Herglotz densities","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"ãp\nwz\nαp\nap","category":"page"},{"location":"implementation/#StableApproxEPW.ãp","page":"Source","title":"StableApproxEPW.ãp","text":"ãp(p)\n\nClosure for the Herglotz polynomial.\n\nThe closure captures the values of the mode number p and does not include any normalization. The function can then be evaluated at any (ζφ) point in the complex strip. Here ζ is the evanescence parameter and φ is the angle indicating the direction of propagation.\n\nThe Herglotz polynomials are defined by\n\na_p = (ζφ)  e^p (ζ + ıφ) qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.wz","page":"Source","title":"StableApproxEPW.wz","text":"wz(; k=1, z=1/4)\n\nClosure to define the weight function.\n\nThe closure captures the values of the wavenumber k and a parameter z. The function can then be evaluated at any ζ point.\n\nThe weight function is defined as\n\nw = ζ  e^z ζ - k sinhζ qquad  ζ  mathbbR\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.αp","page":"Source","title":"StableApproxEPW.αp","text":"αp(p, logweight)\n\nComputation of the normalization constant of the Herglotz polynomial.\n\nThe Herglotz polynomial is defined by a_p, see the function ãp. The normalization constant is defined by\n\nα_p^-2 = 2π int_mathbbR a_p^2 w^2 mathrmdzeta\n\nwhere w is the weight function. The weight function w can be taken to be the function wz.\n\nThe implementation relies on the convenience functions ϵsupport and adaptive_G_quad.\n\ndanger: Beware!\nThe second argument expects the log of the weight function w. This is for numerical stability reasons.\n\nwarning: Warning!\nThe implementation uses some ad-hoc adaptive Gauss quadrature routine. There is probably some room for improvement in the implementation.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.ap","page":"Source","title":"StableApproxEPW.ap","text":"ap(p, logweight)\n\nClosure for the normalized Herglotz polynomial.\n\nThe closure captures the values of the mode number p. The Herglotz polynomial is defined by a_p, see the function ãp. The normalization is given by the second argument, as defined in the documentation of the function αp and is precomputed once for all. The function can then be evaluated at any (ζφ) point in the complex strip. Here ζ is the evanescence parameter and φ is the angle indicating the direction of propagation.\n\nThe normalized Herglotz polynomials are defined by\n\na_p = α_p a_p qquad  p  mathbbZ\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Generalized-plane-waves","page":"Source","title":"Generalized plane waves","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"gpw\napproximation_set","category":"page"},{"location":"implementation/#StableApproxEPW.gpw","page":"Source","title":"StableApproxEPW.gpw","text":"gpw(ζ, φ; k=1)\n\nClosure that defines a generalized plane wave in polar coordinates.\n\nThe closure captures the values of the evanescence parameter ζ, the angle φ and the wavenumber k. It does not include any normalization. The function can then be evaluated at any (rθ) point.\n\nThe generalized plane wave in polar coordinates is defined by\n\nϕ = (rθ)  e^ı k mathbfd  mathbfx\n\nwhere\n\nmathbfd = (cosφ+ıζ sinφ+ıζ)\nqquadtextandqquad\nmathbfx = (r cos θ rsin θ)\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.approximation_set","page":"Source","title":"StableApproxEPW.approximation_set","text":"approximation_set(Y, W; k=1)\n\nGenerate a set of generalized plane waves.\n\nThe parameters Y and W are respectively the sets of complex angles (ζ_jφ_j) and associated weights ω_j corresponding to the generalized plane waves, see gpw\n\nϕ_j = (rθ)  e^ı k mathbfd_j  mathbfx\n\nwhere\n\nmathbfd_j = (cosφ_j+ıζ_j sinφ_j+ıζ_j)\nqquadtextandqquad\nmathbfx = (r cos θ rsin θ)\n\nApproximations are constructed in the form of\n\n(r θ)  sum_j ξ_j ω_j ϕ_j(r θ)\n\nwhere (ξ_j)_j is the set of unknown coefficients.\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\napproximation_set(N; k=1)\n\nGenerate a set of N propagative plane waves with equispaced angles.\n\nThe equispaced angles are defined by\n\nθ_n = 2π s  R qquad n = 0N-1\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\napproximation_set(N, qs, smpl_type; k=1)\napproximation_set(N, Q::Integer, smpl_type; k=1)\n\nGenerate a set of N evanescent plane waves according to some sampling type.\n\nThe second parameter can be an integer Q which controls the truncation parameter of the TruncKernel, or a set of integers qs to specify only some specific terms in the expansion. The parameter smpl_type should be a function name: see uniform_sampling, sobol_sampling and random_sampling.\n\nThe value of the wavenumber k defaults to 1 and can be provided as an optional parameter.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Regularized-SVD-approximation","page":"Source","title":"Regularized SVD approximation","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"RegularizedSVDPseudoInverse\ncondition_number\nsolve_via_regularizedSVD","category":"page"},{"location":"implementation/#StableApproxEPW.RegularizedSVDPseudoInverse","page":"Source","title":"StableApproxEPW.RegularizedSVDPseudoInverse","text":"RegularizedSVDPseudoInverse(A; ϵ=1e-8)\n\nStructure able to solve linear system A using a regularized SVD.\n\nThe threshold ϵ controls the regularization.  Let σ_max be the larger singular value. A singular value σ such that σ leq ϵ σ_max is approximated by zero when solving the least-squares problem.\n\n\n\n\n\n","category":"type"},{"location":"implementation/#StableApproxEPW.condition_number","page":"Source","title":"StableApproxEPW.condition_number","text":"condition_number(B::RegularizedSVDPseudoInverse)\n\nComputes condition number of the matrix for which B was constructed.\n\nThe condition number is defined as the ratio of the largest over the smallest singular values of the matrix A.\n\nκ = fracσ_maxσ_min\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.solve_via_regularizedSVD","page":"Source","title":"StableApproxEPW.solve_via_regularizedSVD","text":"solve_via_regularizedSVD(B::RegularizedSVDPseudoInverse, b)\n\nSolve the linear system Ax=b using the regularized SVD of A.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Parametric-sampling","page":"Source","title":"Parametric sampling","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"TruncKernel\nkernel_diagonal\nprobabilitydensityfunction\ncumulativedensityfunction\nSampler\ninversion\nweight\nrandom_sampling\nuniform_sampling\nsobol_sampling","category":"page"},{"location":"implementation/#StableApproxEPW.TruncKernel","page":"Source","title":"StableApproxEPW.TruncKernel","text":"TruncKernel(P::Integer, logweight)\nTruncKernel(ps::NTuple{N,Int64}, logweight) where N\n\nStructure to hold precomputed normalization constants of Herglotz polynomials.\n\nThis is a convenience structure to hold precomputed normalization constants αp of Herglotz polynomials which are expensive to compute.\n\nAll the normalized Herglotz polynomials a_p (see ap) for p in the argument ps (noted mathcalP) are precomputed and stored in the attribute as which is a Tuple. The logweight function is used to compute the normalization constants. If only an Integer P is given as first argument, the terms in the kernel are the a_p functions for p ranging from -P to P.\n\nA kernel can be evaluated at (x,y) where x=(ζx,φx) and y=(ζy,φy) are points in the complex strip.\n\n(mathbfxmathbfy)  K(mathbfx mathbfy)\n= sum_p in mathcalP overlinea_p(mathbfx) a_p(mathbfy)\n\n\n\n\n\n","category":"type"},{"location":"implementation/#StableApproxEPW.kernel_diagonal","page":"Source","title":"StableApproxEPW.kernel_diagonal","text":"kernel_diagonal(K::TruncKernel)\n\nClosure that defines the evaluation function of the diagonal of a TruncKernel.\n\nmathbfy  K(mathbfy mathbfy)\n= sum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.probabilitydensityfunction","page":"Source","title":"StableApproxEPW.probabilitydensityfunction","text":"probabilitydensityfunction(K::TruncKernel)\n\nProbability density function defined by a TruncKernel.\n\n(ζ φ)  frac1mathcalP K(mathbfy mathbfy)\n= frac1mathcalP sum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\nNotice that it is indeed a PDF since all the a_p functions are orthonormal.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.cumulativedensityfunction","page":"Source","title":"StableApproxEPW.cumulativedensityfunction","text":"cumulativedensityfunction(K::TruncKernel)\n\nCumulative density function defined by a TruncKernel.\n\nThe probability density function is provided by the function probabilitydensityfunction.\n\nζ  frac2πmathcalP int_-infty^ζ K(ζζ) mathrmdζ\n= frac2πmathcalP int_-infty^ζ sum_p in mathcalP a_p^2(ζ) mathrmdζ\n\nwhere, abusing notations, we used K(ζζ) = K(mathbfymathbfy) and a_p^2(ζ) = a_p^2(mathbfy) for any mathbfy = (ζφ) since they both are quantities independent of φ.\n\nThe implementation relies on the convenience functions ϵsupport and adaptive_G_quad.\n\ndanger: Beware!\nThe implementation assumes that the probability density function is constant with respect to the second variable φ. This is the reason why the resulting CDF is a univariate function.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.Sampler","page":"Source","title":"StableApproxEPW.Sampler","text":"Sampler(K::TruncKernel)\n\nStructure to compute sampling nodes and weights.\n\nThe nodes and weights are sampled according to the probability density function defined by a TruncKernel.\n\nnote: Note!\nThe implementation uses the secant method as root finding algorithm to compute the pre-image of the CDF. There is probably some room for improvement in the implementation, specially since we know that the first derivative of the CDF is the PDF. The Newton-Raphson method fails to converge for instance.\n\n\n\n\n\n","category":"type"},{"location":"implementation/#StableApproxEPW.inversion","page":"Source","title":"StableApproxEPW.inversion","text":"inversion(smpl::Sampler, u)\n\nComputes the pre-image ζ of u under the cumulative density function.\n\nThis function allows to perform Inversion Transform Sampling.\n\nThis is a univariate inversion function because the cdf is constant with respect to the other variable φ.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.weight","page":"Source","title":"StableApproxEPW.weight","text":"weight(smpl::Sampler, node)\n\nComputes the weight associated to a node (ζφ).\n\nThe weight at mathbfy=(ζφ) is defined by\n\nω(mathbfy) = sqrtfracmathcalPsum_p in mathcalP a_p(mathbfy)^2\nqquadmathbfy=(ζφ)\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.random_sampling","page":"Source","title":"StableApproxEPW.random_sampling","text":"random_sampling(smpl::Sampler)\nrandom_sampling(smpl::Sampler, M)\n\nDraw M random samples according to the distribution stored in smpl.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.uniform_sampling","page":"Source","title":"StableApproxEPW.uniform_sampling","text":"uniform_sampling(smpl::Sampler, M)\n\nDraw M deterministic samples according to the distribution stored in smpl.\n\nThis has a tensor-like structure, with the same number of samples in both directions.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.sobol_sampling","page":"Source","title":"StableApproxEPW.sobol_sampling","text":"sobol_sampling(smpl::Sampler, M)\n\nDraw M quasi-random samples according to the distribution stored in smpl.\n\nThis function uses Sobol sequences computed according to the package QuasiMonteCarlo.jl.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Dirichlet-sampling","page":"Source","title":"Dirichlet sampling","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"samples_from_nodes\nboundary_sampling_nodes\nnumber_of_boundary_sampling_nodes\nDirichlet_sampling","category":"page"},{"location":"implementation/#StableApproxEPW.samples_from_nodes","page":"Source","title":"StableApproxEPW.samples_from_nodes","text":"samples_from_nodes(f, X)\nsamples_from_nodes(f::Vector, X)\n\nEvaluate f at the sampling nodes X.\n\nIf f is a vector, a matrix is computed.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.boundary_sampling_nodes","page":"Source","title":"StableApproxEPW.boundary_sampling_nodes","text":"boundary_sampling_nodes(S)\n\nThe sampling nodes on the boundary of the unit disk.\n\nThe samplings nodes are then (1 θ_s) with\n\nθ_s = 2π s  S qquad s = 0S-1\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.number_of_boundary_sampling_nodes","page":"Source","title":"StableApproxEPW.number_of_boundary_sampling_nodes","text":"number_of_boundary_sampling_nodes(M; η=2, P=0)\n\nNumber of sampling nodes necessary for an approximation set of dimension M.\n\nThe number of sampling points on the boundary of the unit disk is given by S = max(ηM 2P+1). The (overdetermined) linear system that will be solved is then of size S by M.\n\nThe oversampling parameter η defaults to 2 but can be provided by the user as an optional parameter η. The mode number P defaults to 0 but can be provided by the user as an optional parameter P.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.Dirichlet_sampling","page":"Source","title":"StableApproxEPW.Dirichlet_sampling","text":"Dirichlet_sampling(k, N, U; smpl_type=nothing, η=2, ϵ=1e-14, Q=(length(U)-1)//2)\n\nExample of reconstruction of a solution surrogate via Dirichlet sampling.\n\nThe solution surrogate is defined by its vector of coefficients U. The approximation set of dimension N can be composed of propagative plane waves (default) or evanescent plane waves (depending on the value of smpl_type and Q the maximum mode number assumed to be in the target). The number of sampling points on the boundary can be controlled via the oversampling ration η. The amount of regularization in the SVD can be controlled by the regularization parameter ϵ.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#Convenience-functions","page":"Source","title":"Convenience functions","text":"","category":"section"},{"location":"implementation/","page":"Source","title":"Source","text":"ϵsupport\nadaptive_G_quad","category":"page"},{"location":"implementation/#StableApproxEPW.ϵsupport","page":"Source","title":"StableApproxEPW.ϵsupport","text":"function ϵsupport(f, ϵ; δ=1e-3)\n\nComputes the ϵ-support of a function.\n\nThis is useful to compute quadratures of compactly ϵ-supported functions on unbounded domains.\n\n\n\n\n\n","category":"function"},{"location":"implementation/#StableApproxEPW.adaptive_G_quad","page":"Source","title":"StableApproxEPW.adaptive_G_quad","text":"adaptive_G_quad(f; quadrule=gausslegendre, a=-1, b=1)\n\nComputes the integral of f on ab using adaptive quadrature rule.\n\nHere adaptivity is only understood with respect to the number of nodes. There is no-subdivision of the interval.\n\nnote: Note!\nThe default implementation relies on the FastGaussQuadrature.jl package through the gausslegendre quadrature rule function.\n\n\n\n\n\n","category":"function"},{"location":"example/","page":"Examples","title":"Examples","text":"EditURL = \"<unknown>/example/example.jl\"","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"push!(LOAD_PATH,joinpath(@__DIR__, \"../src/\"))\nusing LinearAlgebra\nusing StableApproxEPW","category":"page"},{"location":"example/#Target-of-the-approximation-problem","page":"Examples","title":"Target of the approximation problem","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We consider the Helmholtz solution in the unit disk, with wavenumber","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"k = 5;\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We need to define the maximum Fourier mode number P in the approximation target:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"P = 25;\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Next we construct the vector of coefficients in the basis b_p for p in [-P,P]:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"U = zeros(ComplexF64, 2P+1);\nU[P+1]     = 0.5;  # This is the constant mode (`p=0`)\nU[P+1 + P] = 1im;  # This is mode `p = P`\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The target of the approximation problem can then be constructed as:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"u = solution_surrogate(U; k=k);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"u can be evaluated at any (r,θ) point. Alternatively, the target u could have been a single mode. For instance, to get the circular wave with mode number p=15, simply set u = bp(15 k=k). Of course, any other function (defined in polar coordinates) can be defined by the user as target of the approximation problem.","category":"page"},{"location":"example/#Reconstruction-method","page":"Examples","title":"Reconstruction method","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"The approximation will be reconstructed by sampling the target on the boundary of the unit disk. To do so, we need to know now the dimension N of the approximation sets that we are going to use:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"N = 100;\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We can determine the number of sampling nodes necessary for a successful reconstruction, based on N, P (to avoid aliasing) and the oversampling ratio η:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"S = number_of_boundary_sampling_nodes(N; η=2, P=P);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The (equispaced) boundary nodes are then constructed as:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"X = boundary_sampling_nodes(S);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The right-hand-side of the linear system can then be readily constructed:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"b = samples_from_nodes(u, X);\nnothing #hide","category":"page"},{"location":"example/#Approximation-with-**propagative**-plane-waves","page":"Examples","title":"Approximation with propagative plane waves","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We construct the approximation set of PPW:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Φppw = approximation_set(N; k=k);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Matrix and its factorization","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Appw = samples_from_nodes(Φppw, X);\niAppw = RegularizedSVDPseudoInverse(Appw; ϵ=1e-14);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The coefficients of the approximation are computed:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"ξppw = solve_via_regularizedSVD(iAppw, b);\nũppw = (r,θ) -> sum([ξi * ϕi(r,θ) for (ξi, ϕi) in zip(ξppw, Φppw)]);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Absolute error function","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"eppw = (r,θ) -> ũppw(r,θ) - u(r,θ); eppw(1,π/2)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Let's compute the relative residual:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"resppw = norm(Appw * ξppw - b) / norm(b)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We did not obtained any accuracy whatsoever! The reason is that the coefficients are too large:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"nrmppw = norm(ξppw) / norm(U)","category":"page"},{"location":"example/#Approximation-with-**evanescent**-plane-waves","page":"Examples","title":"Approximation with evanescent plane waves","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"We construct the approximation set of EPW:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Φepw = approximation_set(N, P, sobol_sampling; k=k);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Matrix and its factorization","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Aepw = samples_from_nodes(Φepw, X);\niAepw = RegularizedSVDPseudoInverse(Aepw; ϵ=1e-14);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The coefficients of the approximation are computed:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"ξepw = solve_via_regularizedSVD(iAepw, b);\nũepw = (r,θ) -> sum([ξi * ϕi(r,θ) for (ξi, ϕi) in zip(ξepw, Φepw)]);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Absolute error function","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"eepw = (r,θ) -> ũepw(r,θ) - u(r,θ); eepw(1,π/2)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"Let's compute the relative residual:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"resepw = norm(Aepw * ξepw - b) / norm(b)","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"We get almost 8 digits of accuracy! The size of the coefficients remains quite high:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"nrmepw = norm(ξepw) / norm(U)","category":"page"},{"location":"example/#Down-to-machine-precision","page":"Examples","title":"Down to machine precision","text":"","category":"section"},{"location":"example/","page":"Examples","title":"Examples","text":"Let's double the number of EPW","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"N = 200","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The above approximation process can be obtained much more rapidly with the following convenience function","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"_, ξepw, ũepw, resepw, nrmepw, eepw = Dirichlet_sampling(k, U, N; smpl_type=sobol_sampling);\nnothing #hide","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"One can check that we obtain now a relative residual very close to machine precision (13 digits of accuracy):","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"resepw","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"The size of the coefficients is also greatly reduced:","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"nrmepw","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"example/","page":"Examples","title":"Examples","text":"This page was generated using Literate.jl.","category":"page"}]
}
