<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Features implemented · Stable Approx with EPW</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Stable Approx with EPW</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Features implemented</a><ul class="internal"><li><a class="tocitem" href="#Circular-waves"><span>Circular waves</span></a></li><li><a class="tocitem" href="#Herglotz-densities"><span>Herglotz densities</span></a></li><li><a class="tocitem" href="#Generalized-plane-waves"><span>Generalized plane waves</span></a></li><li><a class="tocitem" href="#Regularized-SVD-approximation"><span>Regularized SVD approximation</span></a></li><li><a class="tocitem" href="#Parametric-sampling"><span>Parametric sampling</span></a></li><li><a class="tocitem" href="#Dirichlet-sampling"><span>Dirichlet sampling</span></a></li><li><a class="tocitem" href="#Convenience-functions"><span>Convenience functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Features implemented</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Features implemented</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Features-implemented"><a class="docs-heading-anchor" href="#Features-implemented">Features implemented</a><a id="Features-implemented-1"></a><a class="docs-heading-anchor-permalink" href="#Features-implemented" title="Permalink"></a></h1><h2 id="Circular-waves"><a class="docs-heading-anchor" href="#Circular-waves">Circular waves</a><a id="Circular-waves-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-waves" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.b̃p" href="#StableApproxEPW.b̃p"><code>StableApproxEPW.b̃p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">b̃p(p; k=1)</code></pre><p>Closure for the circular wave function in polar coordinates.</p><p>The closure captures the values of the mode number <span>$p$</span> as well as the wavenumber <span>$k$</span> and does not include any normalization. The function can then be evaluated at any <span>$(r,θ)$</span> point.</p><p>The circular waves in polar coordinates are defined by</p><p class="math-container">\[b̃_p := (r,θ) ↦ J_{p}(kr) e^{ı p θ}, \qquad ∀ p ∈ \mathbb{Z}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/circular-waves.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.βp" href="#StableApproxEPW.βp"><code>StableApproxEPW.βp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">βp(p; k=1)</code></pre><p>Computation of the normalization constant of the circular waves.</p><p>The circular wave is defined by <a href="#StableApproxEPW.b̃p"><code>b̃p</code></a> and the normalization is done using the <span>$k$</span>-weighted <span>$H^1$</span> norm.</p><p>By definition</p><p class="math-container">\[    \| b̃_p \|_{H^{1}}^2 = \| b̃_p \|_{L^{2}}^2 + k^{-2} \| \nabla b̃_p \|_{L^{2}}^2.\]</p><p>Using integration by parts,</p><p class="math-container">\[    \| \nabla b̃_p \|_{L^{2}}^2 = k^2 \| b̃_p \|_{L^{2}}^2 + (\partial_n b̃_p , b̃_p).\]</p><p>On the one hand</p><p class="math-container">\[    \| b̃_p \|_{L^{2}}^2 = \pi (J_p^2(k) - J_{p-1}(k)J_{p+1}(k)).\]</p><p>On the other hand</p><p class="math-container">\[    (\partial_n b̃_p , b̃_p) = \pi k (J_{p-1}(k) - J_{p+1}(k))J_p(k).\]</p><p>Hence</p><p class="math-container">\[    \| b̃_p \|_{H^{1}}^2 = 2\pi (J_p^2(k) - J_{p-1}(k)J_{p+1}(k))
    + \pi k^{-1} (J_{p-1}(k) - J_{p+1}(k))J_p(k).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/circular-waves.jl#L17-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.bp" href="#StableApproxEPW.bp"><code>StableApproxEPW.bp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bp(p; k=1)</code></pre><p>Closure for the normalized circular waves.</p><p>The closure captures the values of the mode number <span>$p$</span> and the wavenumber <span>$k$</span>. The normalization is the default normalization defined in the function <a href="#StableApproxEPW.βp"><code>βp</code></a> and is precomputed once for all. The function can then be evaluated at any <span>$(r,θ)$</span> point.</p><p>The normalized circular waves are defined by</p><p class="math-container">\[b_p := β_p b̃_p, \qquad ∀ p ∈ \mathbb{Z}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/circular-waves.jl#L53-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.solution_surrogate" href="#StableApproxEPW.solution_surrogate"><code>StableApproxEPW.solution_surrogate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solution_surrogate(U; k=1)</code></pre><p>Computes a solution surrogate from a set of coefficients <code>U</code>.</p><p>The parameter <code>U</code> is a vector of coefficients <span>$u_p$</span> for <span>$p$</span> ranging from <span>$-P$</span> to <span>$P$</span> (hence of size <span>$2P+1$</span>). The solution surrogate is then</p><p class="math-container">\[\mathbf{x} ↦ \sum_{|p| \leq P} u_p b_{p}(\mathbf{x}).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/circular-waves.jl#L74-L85">source</a></section></article><h2 id="Herglotz-densities"><a class="docs-heading-anchor" href="#Herglotz-densities">Herglotz densities</a><a id="Herglotz-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Herglotz-densities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.ãp" href="#StableApproxEPW.ãp"><code>StableApproxEPW.ãp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ãp(p)</code></pre><p>Closure for the Herglotz polynomial.</p><p>The closure captures the values of the mode number <span>$p$</span> and does not include any normalization. The function can then be evaluated at any <span>$(ζ,φ)$</span> point in the complex strip. Here <span>$ζ$</span> is the evanescence parameter and <span>$φ$</span> is the angle indicating the direction of propagation.</p><p>The Herglotz polynomials are defined by</p><p class="math-container">\[ã_p := (ζ,φ) ↦ e^{p (ζ + ıφ)}, \qquad ∀ p ∈ \mathbb{Z}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/herglotz-densities.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.wz" href="#StableApproxEPW.wz"><code>StableApproxEPW.wz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wz(; k=1, z=1/4)</code></pre><p>Closure to define the weight function.</p><p>The closure captures the values of the wavenumber <span>$k$</span> and a parameter <span>$z$</span>. The function can then be evaluated at any <span>$ζ$</span> point.</p><p>The weight function is defined as</p><p class="math-container">\[w := ζ ↦ e^{z |ζ| - k \sinh|ζ|}, \qquad ∀ ζ ∈ \mathbb{R}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/herglotz-densities.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.αp" href="#StableApproxEPW.αp"><code>StableApproxEPW.αp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">αp(p, logweight)</code></pre><p>Computation of the normalization constant of the Herglotz polynomial.</p><p>The Herglotz polynomial is defined by <span>$ã_p$</span>, see the function <a href="#StableApproxEPW.ãp"><code>ãp</code></a>. The normalization constant is defined by</p><p class="math-container">\[α_p^{-2} := 2π \int_{\mathbb{R}} |ã_p|^{2} w^2 \mathrm{d}\zeta,\]</p><p>where <span>$w$</span> is the weight function. The weight function <span>$w$</span> can be taken to be the function <a href="#StableApproxEPW.wz"><code>wz</code></a>.</p><p>The implementation relies on the convenience functions <a href="#StableApproxEPW.ϵsupport"><code>ϵsupport</code></a> and <a href="#StableApproxEPW.adaptive_G_quad"><code>adaptive_G_quad</code></a>.</p><div class="admonition is-danger"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>The second argument expects the <span>$\log$</span> of the weight function <span>$w$</span>. This is for numerical stability reasons.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning!</header><div class="admonition-body"><p>The implementation uses some ad-hoc adaptive Gauss quadrature routine. There is probably some room for improvement in the implementation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/herglotz-densities.jl#L36-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.ap" href="#StableApproxEPW.ap"><code>StableApproxEPW.ap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ap(p, logweight)</code></pre><p>Closure for the normalized Herglotz polynomial.</p><p>The closure captures the values of the mode number <span>$p$</span>. The Herglotz polynomial is defined by <span>$ã_p$</span>, see the function <a href="#StableApproxEPW.ãp"><code>ãp</code></a>. The normalization is given by the second argument, as defined in the documentation of the function <a href="#StableApproxEPW.αp"><code>αp</code></a> and is precomputed once for all. The function can then be evaluated at any <span>$(ζ,φ)$</span> point in the complex strip. Here <span>$ζ$</span> is the evanescence parameter and <span>$φ$</span> is the angle indicating the direction of propagation.</p><p>The normalized Herglotz polynomials are defined by</p><p class="math-container">\[a_p := α_p ã_p, \qquad ∀ p ∈ \mathbb{Z}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/herglotz-densities.jl#L86-L103">source</a></section></article><h2 id="Generalized-plane-waves"><a class="docs-heading-anchor" href="#Generalized-plane-waves">Generalized plane waves</a><a id="Generalized-plane-waves-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-plane-waves" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.gpw" href="#StableApproxEPW.gpw"><code>StableApproxEPW.gpw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gpw(ζ, φ; k=1)</code></pre><p>Closure that defines a generalized plane wave in polar coordinates.</p><p>The closure captures the values of the evanescence parameter <span>$ζ$</span>, the angle <span>$φ$</span> and the wavenumber <span>$k$</span>. It does not include any normalization. The function can then be evaluated at any <span>$(r,θ)$</span> point.</p><p>The generalized plane wave in polar coordinates is defined by</p><p class="math-container">\[ϕ := (r,θ) ↦ e^{ı k \mathbf{d} ⋅ \mathbf{x}},\]</p><p>where</p><p class="math-container">\[\mathbf{d} = (\cos[φ+ıζ], \sin[φ+ıζ]),
\qquad\text{and}\qquad
\mathbf{x} = (r \cos θ, r\sin θ).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/plane-waves.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.approximation_set" href="#StableApproxEPW.approximation_set"><code>StableApproxEPW.approximation_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">approximation_set(Y, W; k=1)</code></pre><p>Generate a set of generalized plane waves.</p><p>The parameters <code>Y</code> and <code>W</code> are respectively the sets of complex angles <span>$(ζ_j,φ_j)$</span> and associated weights <span>$ω_j$</span> corresponding to the generalized plane waves, see <a href="#StableApproxEPW.gpw"><code>gpw</code></a></p><p class="math-container">\[ϕ_j := (r,θ) ↦ e^{ı k \mathbf{d}_j ⋅ \mathbf{x}},\]</p><p>where</p><p class="math-container">\[\mathbf{d}_j = (\cos[φ_j+ıζ_j], \sin[φ_j+ıζ_j]),
\qquad\text{and}\qquad
\mathbf{x} = (r \cos θ, r\sin θ).\]</p><p>Approximations are constructed in the form of</p><p class="math-container">\[(r, θ) ↦ \sum_j ξ_j ω_j ϕ_j(r, θ),\]</p><p>where <span>$(ξ_j)_j$</span> is the set of unknown coefficients.</p><p>The value of the wavenumber <code>k</code> defaults to <span>$1$</span> and can be provided as an optional parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/plane-waves.jl#L27-L52">source</a></section><section><div><pre><code class="nohighlight hljs">approximation_set(N; k=1)</code></pre><p>Generate a set of <span>$N$</span> propagative plane waves with equispaced angles.</p><p>The equispaced angles are defined by</p><p class="math-container">\[θ_n := 2π s / R, \qquad n = 0,…,N-1.\]</p><p>The value of the wavenumber <code>k</code> defaults to <span>$1$</span> and can be provided as an optional parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/plane-waves.jl#L58-L70">source</a></section><section><div><pre><code class="nohighlight hljs">approximation_set(N, qs, smpl_type; k=1)
approximation_set(N, Q::Integer, smpl_type; k=1)</code></pre><p>Generate a set of <span>$N$</span> evanescent plane waves according to some sampling type.</p><p>The second parameter can be an integer <span>$Q$</span> which controls the truncation parameter of the <a href="#StableApproxEPW.TruncKernel"><code>TruncKernel</code></a>, or a set of integers <code>qs</code> to specify only some specific terms in the expansion. The parameter <code>smpl_type</code> should be a function name: see <a href="#StableApproxEPW.uniform_sampling"><code>uniform_sampling</code></a>, <a href="#StableApproxEPW.sobol_sampling"><code>sobol_sampling</code></a> and <a href="#StableApproxEPW.random_sampling"><code>random_sampling</code></a>.</p><p>The value of the wavenumber <code>k</code> defaults to <span>$1$</span> and can be provided as an optional parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/plane-waves.jl#L77-L92">source</a></section></article><h2 id="Regularized-SVD-approximation"><a class="docs-heading-anchor" href="#Regularized-SVD-approximation">Regularized SVD approximation</a><a id="Regularized-SVD-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Regularized-SVD-approximation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.RegularizedSVDPseudoInverse" href="#StableApproxEPW.RegularizedSVDPseudoInverse"><code>StableApproxEPW.RegularizedSVDPseudoInverse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedSVDPseudoInverse(A; ϵ=1e-8)</code></pre><p>Structure able to solve linear system <code>A</code> using a regularized SVD.</p><p>The threshold <code>ϵ</code> controls the regularization.  Let <span>$σ_{\max}$</span> be the larger singular value. A singular value <span>$σ$</span> such that <span>$σ \leq ϵ σ_{\max}$</span> is approximated by zero when solving the least-squares problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/regularizedSVD.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.condition_number" href="#StableApproxEPW.condition_number"><code>StableApproxEPW.condition_number</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">condition_number(B::RegularizedSVDPseudoInverse)</code></pre><p>Computes condition number of the matrix for which <code>B</code> was constructed.</p><p>The condition number is defined as the ratio of the largest over the smallest singular values of the matrix <span>$A$</span>.</p><p class="math-container">\[κ := \frac{σ_{\max}}{σ_{\min}}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/regularizedSVD.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.solve_via_regularizedSVD" href="#StableApproxEPW.solve_via_regularizedSVD"><code>StableApproxEPW.solve_via_regularizedSVD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_via_regularizedSVD(B::RegularizedSVDPseudoInverse, b)</code></pre><p>Solve the linear system <span>$Ax=b$</span> using the regularized SVD of <span>$A$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/regularizedSVD.jl#L43-L47">source</a></section></article><h2 id="Parametric-sampling"><a class="docs-heading-anchor" href="#Parametric-sampling">Parametric sampling</a><a id="Parametric-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.TruncKernel" href="#StableApproxEPW.TruncKernel"><code>StableApproxEPW.TruncKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TruncKernel(P::Integer, logweight)
TruncKernel(ps::NTuple{N,Int64}, logweight) where N</code></pre><p>Structure to hold precomputed normalization constants of Herglotz polynomials.</p><p>This is a convenience structure to hold precomputed normalization constants <a href="#StableApproxEPW.αp"><code>αp</code></a> of Herglotz polynomials which are expensive to compute.</p><p>All the normalized Herglotz polynomials <span>$a_p$</span> (see <a href="#StableApproxEPW.ap"><code>ap</code></a>) for <span>$p$</span> in the argument <code>ps</code> (noted <span>$\mathcal{P}$</span>) are precomputed and stored in the attribute <code>as</code> which is a <code>Tuple</code>. The <code>logweight</code> function is used to compute the normalization constants. If only an <code>Integer</code> <span>$P$</span> is given as first argument, the terms in the kernel are the <span>$a_p$</span> functions for <span>$p$</span> ranging from <span>$-P$</span> to <span>$P$</span>.</p><p>A kernel can be evaluated at <code>(x,y)</code> where <code>x=(ζx,φx)</code> and <code>y=(ζy,φy)</code> are points in the complex strip.</p><p class="math-container">\[(\mathbf{x},\mathbf{y}) ↦ K(\mathbf{x}, \mathbf{y})
= \sum_{p \in \mathcal{P}} \overline{a_{p}(\mathbf{x})} a_{p}(\mathbf{y}).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.kernel_diagonal" href="#StableApproxEPW.kernel_diagonal"><code>StableApproxEPW.kernel_diagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel_diagonal(K::TruncKernel)</code></pre><p>Closure that defines the evaluation function of the diagonal of a <a href="#StableApproxEPW.TruncKernel"><code>TruncKernel</code></a>.</p><p class="math-container">\[\mathbf{y} ↦ K(\mathbf{y}, \mathbf{y})
= \sum_{p \in \mathcal{P}} |a_{p}(\mathbf{y})|^2,
\qquad\mathbf{y}=(ζ,φ).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.probabilitydensityfunction" href="#StableApproxEPW.probabilitydensityfunction"><code>StableApproxEPW.probabilitydensityfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probabilitydensityfunction(K::TruncKernel)</code></pre><p>Probability density function defined by a <a href="#StableApproxEPW.TruncKernel"><code>TruncKernel</code></a>.</p><p class="math-container">\[(ζ, φ) ↦ \frac{1}{|\mathcal{P}|} K(\mathbf{y}, \mathbf{y})
= \frac{1}{|\mathcal{P}|} \sum_{p \in \mathcal{P}} |a_{p}(\mathbf{y})|^2,
\qquad\mathbf{y}=(ζ,φ).\]</p><p>Notice that it is indeed a PDF since all the <span>$a_p$</span> functions are orthonormal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.cumulativedensityfunction" href="#StableApproxEPW.cumulativedensityfunction"><code>StableApproxEPW.cumulativedensityfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cumulativedensityfunction(K::TruncKernel)</code></pre><p>Cumulative density function defined by a <a href="#StableApproxEPW.TruncKernel"><code>TruncKernel</code></a>.</p><p>The probability density function is provided by the function <a href="#StableApproxEPW.probabilitydensityfunction"><code>probabilitydensityfunction</code></a>.</p><p class="math-container">\[ζ ↦ \frac{2π}{|\mathcal{P}|} \int_{-\infty}^{ζ} K(ζ,ζ) \mathrm{d}ζ
= \frac{2π}{|\mathcal{P}|} \int_{-\infty}^{ζ} \sum_{p \in \mathcal{P}} |a_{p}|^2(ζ) \mathrm{d}ζ,\]</p><p>where, abusing notations, we used <span>$K(ζ,ζ) = K(\mathbf{y},\mathbf{y})$</span> and <span>$|a_{p}|^2(ζ) = |a_{p}|^2(\mathbf{y})$</span> for any <span>$\mathbf{y} = (ζ,φ)$</span> since they both are quantities independent of <span>$φ$</span>.</p><p>The implementation relies on the convenience functions <a href="#StableApproxEPW.ϵsupport"><code>ϵsupport</code></a> and <a href="#StableApproxEPW.adaptive_G_quad"><code>adaptive_G_quad</code></a>.</p><div class="admonition is-danger"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>The implementation <em>assumes</em> that the probability density function is constant with respect to the second variable <span>$φ$</span>. This is the reason why the resulting CDF is a univariate function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L78-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.Sampler" href="#StableApproxEPW.Sampler"><code>StableApproxEPW.Sampler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sampler(K::TruncKernel)</code></pre><p>Structure to compute sampling nodes and weights.</p><p>The nodes and weights are sampled according to the probability density function defined by a <a href="#StableApproxEPW.TruncKernel"><code>TruncKernel</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note!</header><div class="admonition-body"><p>The implementation uses the secant method as root finding algorithm to compute the pre-image of the CDF. There is probably some room for improvement in the implementation, specially since we know that the first derivative of the CDF is the PDF. The Newton-Raphson method fails to converge for instance.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.inversion" href="#StableApproxEPW.inversion"><code>StableApproxEPW.inversion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inversion(smpl::Sampler, u)</code></pre><p>Computes the pre-image <span>$ζ$</span> of <code>u</code> under the cumulative density function.</p><p>This function allows to perform <em>Inversion Transform Sampling</em>.</p><p>This is a univariate inversion function because the cdf is constant with respect to the other variable <span>$φ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L167-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.weight" href="#StableApproxEPW.weight"><code>StableApproxEPW.weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight(smpl::Sampler, node)</code></pre><p>Computes the weight associated to a node <span>$(ζ,φ)$</span>.</p><p>The weight at <span>$\mathbf{y}=(ζ,φ)$</span> is defined by</p><p class="math-container">\[ω(\mathbf{y}) := \sqrt{\frac{|\mathcal{P}|}{\sum_{p \in \mathcal{P}} |a_{p}(\mathbf{y})|^2}},
\qquad\mathbf{y}=(ζ,φ).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.random_sampling" href="#StableApproxEPW.random_sampling"><code>StableApproxEPW.random_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_sampling(smpl::Sampler)
random_sampling(smpl::Sampler, M)</code></pre><p>Draw <code>M</code> random samples according to the distribution stored in <code>smpl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.uniform_sampling" href="#StableApproxEPW.uniform_sampling"><code>StableApproxEPW.uniform_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniform_sampling(smpl::Sampler, M)</code></pre><p>Draw <code>M</code> deterministic samples according to the distribution stored in <code>smpl</code>.</p><p>This has a tensor-like structure, with the same number of samples in both directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.sobol_sampling" href="#StableApproxEPW.sobol_sampling"><code>StableApproxEPW.sobol_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sobol_sampling(smpl::Sampler, M)</code></pre><p>Draw <code>M</code> quasi-random samples according to the distribution stored in <code>smpl</code>.</p><p>This function uses Sobol sequences computed according to the package <a href="https://github.com/SciML/QuasiMonteCarlo.jl">QuasiMonteCarlo.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/parametric_sampling.jl#L240-L247">source</a></section></article><h2 id="Dirichlet-sampling"><a class="docs-heading-anchor" href="#Dirichlet-sampling">Dirichlet sampling</a><a id="Dirichlet-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-sampling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.samples_from_nodes" href="#StableApproxEPW.samples_from_nodes"><code>StableApproxEPW.samples_from_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">samples_from_nodes(f, X)
samples_from_nodes(f::Vector, X)</code></pre><p>Evaluate <code>f</code> at the sampling nodes <code>X</code>.</p><p>If <code>f</code> is a vector, a matrix is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/dirichlet_sampling.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.boundary_sampling_nodes" href="#StableApproxEPW.boundary_sampling_nodes"><code>StableApproxEPW.boundary_sampling_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundary_sampling_nodes(S)</code></pre><p>The sampling nodes on the boundary of the unit disk.</p><p>The samplings nodes are then <span>$(1, θ_s)$</span> with</p><p class="math-container">\[θ_s := 2π s / S, \qquad s = 0,…,S-1.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/dirichlet_sampling.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.number_of_boundary_sampling_nodes" href="#StableApproxEPW.number_of_boundary_sampling_nodes"><code>StableApproxEPW.number_of_boundary_sampling_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_of_boundary_sampling_nodes(M; η=2, P=0)</code></pre><p>Number of sampling nodes necessary for an approximation set of dimension <span>$M$</span>.</p><p>The number of sampling points on the boundary of the unit disk is given by <span>$S := \max(ηM, 2P+1)$</span>. The (overdetermined) linear system that will be solved is then of size <span>$S$</span> by <span>$M$</span>.</p><p>The oversampling parameter <span>$η$</span> defaults to <span>$2$</span> but can be provided by the user as an optional parameter <code>η</code>. The mode number <span>$P$</span> defaults to <span>$0$</span> but can be provided by the user as an optional parameter <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/dirichlet_sampling.jl#L26-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.Dirichlet_sampling" href="#StableApproxEPW.Dirichlet_sampling"><code>StableApproxEPW.Dirichlet_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Dirichlet_sampling(k, N, U; smpl_type=nothing, η=2, ϵ=1e-8, Q=(length(U)-1)//2)</code></pre><p>Example of reconstruction of a solution surrogate via Dirichlet sampling.</p><p>The solution surrogate is defined by its vector of coefficients <code>U</code>. The approximation set of dimension <code>N</code> can be composed of propagative plane waves (default) or evanescent plane waves (depending on the value of <code>smpl_type</code> and <code>Q</code> the maximum mode number assumed to be in the target). The number of sampling points on the boundary can be controlled via the oversampling ration <code>η</code>. The amount of regularization in the SVD can be controlled by the regularization parameter <code>ϵ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/dirichlet_sampling.jl#L43-L56">source</a></section></article><h2 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.ϵsupport" href="#StableApproxEPW.ϵsupport"><code>StableApproxEPW.ϵsupport</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ϵsupport(f, ϵ; δ=1e-3)</code></pre><p>Computes the ϵ-support of a function.</p><p>This is useful to compute quadratures of compactly ϵ-supported functions on unbounded domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/adaptive-quad-rule.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StableApproxEPW.adaptive_G_quad" href="#StableApproxEPW.adaptive_G_quad"><code>StableApproxEPW.adaptive_G_quad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_G_quad(f; quadrule=gausslegendre, a=-1, b=1)</code></pre><p>Computes the integral of <span>$f$</span> on <span>$[a,b]$</span> using adaptive quadrature rule.</p><p>Here adaptivity is only understood with respect to the number of nodes. There is no-subdivision of the interval.</p><div class="admonition is-info"><header class="admonition-header">Note!</header><div class="admonition-body"><p>The default implementation relies on the <a href="https://github.com/JuliaApproximation/FastGaussQuadrature.jl">FastGaussQuadrature.jl</a> package through the <code>gausslegendre</code> quadrature rule function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EmileParolin/evanescent-plane-wave-approx/blob/febfcdf959c1fc991a141d875f40f4e53cfcbadc/src/adaptive-quad-rule.jl#L16-L28">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 31 January 2022 11:15">Monday 31 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
